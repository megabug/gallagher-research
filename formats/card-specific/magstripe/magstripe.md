# Cardax Magstripe

## About

Although barely seen out in the field anymore, the Cardax system at one time supported magstripe-based cards. These don't use the common [card credential format](../../cardholder/cardholder.md) that the other cards do, but instead use a magstripe-specific format.

## Format

Only [track 1](https://en.wikipedia.org/wiki/Magnetic_stripe_card#Financial_cards) of the card is used, and uses the DEC SIXBIT encoding.

### Step 1

First, the following block of data is awkwardly generated by slicing up the various-length data items into five-bit characters:

| &nbsp;  | Char 0 | Char 1 | Char 2 | Char 3 | Char 4 | Char 5 | Char 6 | Char 7 |
|---------|--------|--------|--------|--------|--------|--------|--------|-------- |
| **+0**  | RC | FC<sub>11-15</sub> | FC<sub>6-10</sub> | FC<sub>1-5</sub> | FC<sub>0</sub>,<br>`0x00` | `0x00` | `0x00` | `0x00` |
| **+8**  | `0x00` | `0x00` | `0x00` | CN<sub>13-15</sub> | CN<sub>8-12</sub> | CN<sub>3-7</sub> | CN<sub>0-2</sub>,<br>IL<sub>2-3</sub> | IL<sub>0-1</sub>,<br>`0x00` |
| **+16** | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00`,<br>CS<sub>14-15</sub> | CS<sub>9-13</sub> |
| **+24** | CS<sub>4-8</sub> | CS<sub>0-3</sub>,<br>`0x00` |

Note that *X<sub>Y-Z</sub>* indicates the *Yth* to *Zth* bits of *X*, and *A, B* indicates the two values *A* and *B* concatenated into a single character.

Note that the CN in this case is limited to 16 bits, hence magstripe card numbers can only range up to 65,535 (nominally 50,000).

Here, CS stands for the checksum, which is given by the following algorithm:

```
r <- 0
for c in input:
    r <- (r ^ 0xA5963C) << 8
    repeat 24 times:
        r <- r << 1
        if no carry out:
            r <- r ^ c
            c <- c ^ 0xFF
result <- r & 0xFFFF
```

This algorithm is run over the following (8-bit byte) input:

| &nbsp;  | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 |
|---------|----|----|----|----|----|----|----|---- |
| **+0**  | `P` | `A` | `1` | RC | FC<sub>8-15</sub> | FC<sub>0-7</sub> | `0x00` | `0x00` |
| **+8**  | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | CN<sub>8-15</sub> |
| **+16** | CN<sub>0-7</sub> | IL | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` |
| **+24** | `0x00` | `0x00` |

### Step 2

The index of each character is added to each character itself, modulo 0x1F. That is:
* For the 0th character, nothing changes.
* For the 1st character, 1 is added.
* For the 2nd character, 2 is added.
* And so on...

### Step 3

The entire block is mapped through a substitution table, where each 7-bit character produces the final output character:

| &nbsp;    | ..000 | ..001 | ..010 | ..011 | ..100 | ..101 | ..110 | ..111 |
|-----------|-------|-------|-------|-------|-------|-------|-------|-------|
| **00...** | `4`   | `V`   | `/`   | `Q`   | `5`   | `A`   | `0`   | ` `   |
| **01...** | `.`   | `9`   | `W`   | `(`   | `2`   | `I`   | `-`   | `X`   |
| **10...** | `S`   | `U`   | `G`   | `8`   | `J`   | `7`   | `Y`   | `P`   |
| **11...** | `O`   | `R`   | `H`   | `T`   | `E`   | `1`   | `B`   | `Z`   |

### Step 4

Finally, the resulting track 1 data is simply (!) the string `PA1` followed by the mapped data.


## Example

Take the following data read off track 1 of a magstripe card: `PA12Q-BJA0 .9WGE-/ SUG8J7P7SU`

We can see and strip off the fixed `PA1` header, leading to the mapped data `2Q-BJA0 .9WGE-/ SUG8J7P7SU`. Unmapping this through the substitution table, we get the bitstream:

```
01100 00011 01110 11110 10100 00101 00110 00111 01000 01001
01010 10010 11100 01110 00010 00111 10000 10001 10010 10011
10100 10101 10111 10101 10000 10001
```

We then subtract the position of each character from the characters themselves, giving:

```
01100 00010 01100 11011 10000 00000 00000 00000 00000 00000
00000 00111 10000 00001 10100 11000 00000 00000 00000 00000
00000 00000 00001 11110 11000 11000
```

This can be arranged as follows:

| &nbsp;  | Char 0 | Char 1 | Char 2 | Char 3 | Char 4 | Char 5 | Char 6 | Char 7 |
|---------|--------|--------|--------|--------|--------|--------|--------|--------|
| **+0**  | RC | FC<sub>11-15</sub> | FC<sub>6-10</sub> | FC<sub>1-5</sub> | FC<sub>0</sub>,<br>`0x00` | `0x00` | `0x00` | `0x00` |
|         | 01100 | 00010 | 01100 | 11011 | 10000 | 00000 | 00000 | 00000 |
| **+8**  | `0x00` | `0x00` | `0x00` | CN<sub>13-15</sub> | CN<sub>8-12</sub> | CN<sub>3-7</sub> | CN<sub>0-2</sub>,<br>IL<sub>2-3</sub> | IL<sub>0-1</sub>,<br>`0x00` |
|         | 00000 | 00000 | 00000 | 00111 | 10000 | 00001 | 10100 | 11000 |
| **+16** | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00`,<br>CS<sub>14-15</sub> | CS<sub>9-13</sub> |
|         | 00000 | 00000 | 00000 | 00000 | 00000 | 00000 | 00001 | 11110 |
| **+24** | CS<sub>4-8</sub> | CS<sub>0-3</sub>,<br>`0x00` |
|         | 11000 | 11000 |

Reading off the fields, we get:

* RC = 0b1100 = 12 (M)
* FC = 0b0001001100110111 = 0x1337 = 4919
* CN = 0b1111000000001101 = 0xF00D = 61453
* IL = 0b0011 = 3
* CS = 0b0111110110001100 = 0x7D8C

We can verify the checksum by arranging the data for the checksum input:

| &nbsp;  | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 |
|---------|----|----|----|----|----|----|----|---- |
| **+0**  | `P` | `A` | `1` | RC | FC<sub>8-15</sub> | FC<sub>0-7</sub> | `0x00` | `0x00` |
|         | `P` | `A` | `1` | `0x0C` | `0x13` | `0x37` | `0x00` | `0x00` |
| **+8**  | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | CN<sub>8-15</sub> |
|         | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0xF0` |
| **+16** | CN<sub>0-7</sub> | IL | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` |
|         | `0x0D` | `0x3` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` | `0x00` |
| **+24** | `0x00` | `0x00` |
|         | `0x00` | `0x00` |

Then run it on the checksum algorithm:

```python
>>> d = 'PA1'.encode('ascii')
>>> d += bytearray.fromhex('0C 13 37 00 00 00 00 00 00 00 00 00 F0 0D 03 00 00 00
00 00 00 00 00')
>>> r = 0
>>> for c in d:
...     r = (r ^ 0xA5963C) << 8
...     for _ in range(24):
...             r <<= 1
...             if not r & (1 << 32):
...                     r ^= c
...                     c ^= 0xFF
...
>>> hex(r & 0xFFFF)
'0x7d8c'
```
